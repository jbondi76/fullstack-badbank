"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectGenerator = void 0;
const lodash_1 = require("lodash");
const DECRYPTED_KEYS = Symbol.for('@@mdb.decryptedKeys');
function maybeDecorateWithDecryptedKeys(object, element) {
    if (element.isValueDecrypted()) {
        if (!object[DECRYPTED_KEYS]) {
            Object.defineProperty(object, DECRYPTED_KEYS, {
                value: [],
                writable: true,
                configurable: true,
                enumerable: false,
            });
        }
        object[DECRYPTED_KEYS].push(String(element.currentKey));
    }
}
const DoesNotExist = Symbol('DoesNotExist');
class ObjectGenerator {
    static generate(elements, options = {}) {
        if (elements) {
            const object = {};
            for (const element of elements) {
                if (options.excludeInternalFields && element.isInternalField()) {
                    continue;
                }
                if (!element.isRemoved() && element.currentKey !== '') {
                    object[element.currentKey] = element.generateObject(options);
                    maybeDecorateWithDecryptedKeys(object, element);
                }
            }
            return object;
        }
        return elements;
    }
    static generateOriginal(elements, options = {}) {
        if (elements) {
            const object = {};
            for (const element of elements) {
                if (options.excludeInternalFields && element.isInternalField()) {
                    continue;
                }
                if (!element.isAdded()) {
                    object[element.key] = element.generateOriginalObject(options);
                    maybeDecorateWithDecryptedKeys(object, element);
                }
            }
            return object;
        }
        return elements;
    }
    static generateArray(elements, options = {}) {
        if (elements) {
            const array = [];
            for (const element of elements) {
                if (options.excludeInternalFields && element.isInternalField()) {
                    continue;
                }
                if (!element.isRemoved()) {
                    if (element.elements) {
                        array.push(element.generateObject(options));
                    }
                    else {
                        array.push(element.currentValue);
                    }
                    maybeDecorateWithDecryptedKeys(array, element);
                }
            }
            return array;
        }
        return elements;
    }
    static generateOriginalArray(elements, options = {}) {
        if (elements) {
            const array = [];
            for (const element of elements) {
                if (options.excludeInternalFields && element.isInternalField()) {
                    continue;
                }
                if (element.originalExpandableValue) {
                    array.push(element.generateOriginalObject(options));
                }
                else if (!element.isAdded()) {
                    array.push(element.value);
                }
                maybeDecorateWithDecryptedKeys(array, element);
            }
            return array;
        }
        return elements;
    }
    static recursivelyGatherFieldsAndValuesForUpdate(target, keyInclusionOptions, includeUpdatedFields) {
        const originalFields = [];
        const newFields = [];
        const alwaysIncludeKeys = keyInclusionOptions.alwaysIncludeKeys ?? [];
        const includableEncryptedKeys = keyInclusionOptions.includableEncryptedKeys ?? [];
        for (const element of target.elements ?? []) {
            const isArrayIndex = target.currentType === 'Array';
            const canIncludeOriginalValue = !element.isValueDecrypted() ||
                includableEncryptedKeys.some((key) => key.length === 1 && key[0] === String(element.key));
            if ((includeUpdatedFields &&
                element.isModified() &&
                !element.isAdded() &&
                !element.hasChangedKey()) ||
                alwaysIncludeKeys.some((key) => key[0] === String(element.key))) {
                if (element.elements &&
                    !alwaysIncludeKeys.some((key) => key.length === 1 && key[0] === String(element.key)) &&
                    ((element.type === 'Object' && element.currentType === 'Object') ||
                        (element.type === 'Array' &&
                            element.currentType === 'Array' &&
                            !element.hasAnyRemovedChild()))) {
                    const filterAndShiftFieldPaths = (paths) => paths
                        .filter((key) => key[0] === String(element.key))
                        .map((key) => key.slice(1))
                        .filter((key) => key.length > 0);
                    const nestedKeyInclusionOptions = {
                        alwaysIncludeKeys: filterAndShiftFieldPaths(alwaysIncludeKeys),
                        includableEncryptedKeys: filterAndShiftFieldPaths(includableEncryptedKeys),
                    };
                    const nestedResult = ObjectGenerator.recursivelyGatherFieldsAndValuesForUpdate(element, nestedKeyInclusionOptions, includeUpdatedFields);
                    for (const { path, value } of nestedResult.originalFields) {
                        originalFields.push({
                            path: [{ key: String(element.key), isArrayIndex }, ...path],
                            value,
                        });
                    }
                    for (const { path, value } of nestedResult.newFields) {
                        newFields.push({
                            path: [
                                { key: String(element.currentKey), isArrayIndex },
                                ...path,
                            ],
                            value,
                        });
                    }
                }
                else {
                    if (canIncludeOriginalValue) {
                        originalFields.push({
                            path: [{ key: String(element.key), isArrayIndex }],
                            value: element.generateOriginalObject(),
                        });
                    }
                    if (includeUpdatedFields &&
                        element.currentKey !== '' &&
                        !element.isRemoved()) {
                        newFields.push({
                            path: [{ key: String(element.currentKey), isArrayIndex }],
                            value: element.generateObject(),
                        });
                    }
                }
            }
            if (includeUpdatedFields &&
                !element.isRemoved() &&
                (element.isAdded() || element.hasChangedKey()) &&
                element.currentKey !== '') {
                let wasRenamedToKeyOfPreviouslyExistingElement = false;
                for (const otherElement of target.elements ?? []) {
                    if (otherElement !== element &&
                        otherElement.key === element.currentKey) {
                        wasRenamedToKeyOfPreviouslyExistingElement = true;
                        break;
                    }
                }
                if (!wasRenamedToKeyOfPreviouslyExistingElement) {
                    originalFields.push({
                        path: [{ key: String(element.currentKey), isArrayIndex }],
                        value: DoesNotExist,
                    });
                }
                newFields.push({
                    path: [{ key: String(element.currentKey), isArrayIndex }],
                    value: element.generateObject(),
                });
            }
            if (includeUpdatedFields &&
                !element.isAdded() &&
                (element.isRemoved() || element.hasChangedKey()) &&
                element.key !== '') {
                if (canIncludeOriginalValue) {
                    originalFields.push({
                        path: [{ key: String(element.key), isArrayIndex }],
                        value: element.generateOriginalObject(),
                    });
                }
                let wasRemovedAndLaterReplacedByNewElement = false;
                for (const otherElement of target.elements ?? []) {
                    if (otherElement !== element &&
                        otherElement.currentKey === element.key) {
                        wasRemovedAndLaterReplacedByNewElement = true;
                        break;
                    }
                }
                if (!wasRemovedAndLaterReplacedByNewElement) {
                    newFields.push({
                        path: [{ key: String(element.key), isArrayIndex }],
                        value: DoesNotExist,
                    });
                }
            }
        }
        for (let i = 0; i < newFields.length;) {
            const entry = newFields[i];
            if (entry.value === DoesNotExist) {
                if (newFields.some((otherEntry) => (0, lodash_1.isEqual)(otherEntry.path, entry.path) && entry !== otherEntry)) {
                    newFields.splice(i, 1);
                    continue;
                }
            }
            i++;
        }
        return { originalFields, newFields };
    }
    static createGetFieldExpr(path) {
        return path.reduce((input, { key, isArrayIndex }) => isArrayIndex
            ? {
                $arrayElemAt: [input, +key],
            }
            : {
                $getField: {
                    field: { $literal: key },
                    input,
                },
            }, '$$ROOT');
    }
    static createSetFieldExpr(path, value) {
        return path.reduceRight((value, { key, isArrayIndex }, idx, array) => {
            const input = ObjectGenerator.createGetFieldExpr(array.slice(0, idx));
            if (!isArrayIndex) {
                return {
                    $setField: {
                        field: { $literal: key },
                        input,
                        value,
                    },
                };
            }
            return {
                $let: {
                    vars: { input },
                    in: {
                        $concatArrays: [
                            ...(+key > 0 ? [{ $slice: ['$$input', 0, +key] }] : []),
                            [value],
                            { $slice: ['$$input', +key + 1, 2 ** 31 - 1] },
                        ],
                    },
                },
            };
        }, (value === DoesNotExist ? '$$REMOVE' : { $literal: value }));
    }
    static getQueryForOriginalKeysAndValuesForSpecifiedFields(target, keyInclusionOptions, includeUpdatedFields) {
        const { originalFields } = ObjectGenerator.recursivelyGatherFieldsAndValuesForUpdate(target, keyInclusionOptions, includeUpdatedFields);
        const query = {};
        if (originalFields.some(({ path }) => path.some(({ key }) => key.includes('.') || key.startsWith('$')))) {
            const equalityMatches = [];
            for (const { path, value } of originalFields) {
                const getFieldExpr = ObjectGenerator.createGetFieldExpr(path);
                equalityMatches.push(value !== DoesNotExist
                    ? { $eq: [getFieldExpr, { $literal: value }] }
                    : { $eq: [{ $type: getFieldExpr }, 'missing'] });
            }
            if (equalityMatches.length === 1) {
                query.$expr = equalityMatches[0];
            }
            else if (equalityMatches.length > 1) {
                query.$expr = { $and: equalityMatches };
            }
        }
        else {
            for (const { path, value } of originalFields) {
                const matchValue = value === DoesNotExist ? { $exists: false } : value;
                query[path.map(({ key }) => key).join('.')] = matchValue;
            }
        }
        return query;
    }
    static generateUpdateDoc(target) {
        const { newFields } = ObjectGenerator.recursivelyGatherFieldsAndValuesForUpdate(target, {}, true);
        if (newFields.some(({ path }) => path.some(({ key }) => key.includes('.') || key.startsWith('$')))) {
            return newFields.map(({ path, value }) => {
                return {
                    $replaceWith: ObjectGenerator.createSetFieldExpr(path, value),
                };
            });
        }
        else {
            const updateDoc = {};
            for (const { path, value } of newFields) {
                if (value === DoesNotExist) {
                    updateDoc.$unset ??= {};
                    updateDoc.$unset[path.map(({ key }) => key).join('.')] = true;
                }
                else {
                    updateDoc.$set ??= {};
                    updateDoc.$set[path.map(({ key }) => key).join('.')] = value;
                }
            }
            return updateDoc;
        }
    }
}
exports.ObjectGenerator = ObjectGenerator;
exports.default = ObjectGenerator;
//# sourceMappingURL=object-generator.js.map