'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ElementList = exports.Element = exports.isInternalFieldPath = exports.Events = exports.DATE_FORMAT = void 0;
const eventemitter3_1 = __importDefault(require("eventemitter3"));
const lodash_1 = require("lodash");
const object_generator_1 = __importDefault(require("./object-generator"));
const hadron_type_checker_1 = __importDefault(require("hadron-type-checker"));
const bson_1 = require("bson");
const date_1 = __importDefault(require("./editor/date"));
const element_events_1 = __importDefault(require("./element-events"));
exports.Events = element_events_1.default;
const utils_1 = require("./utils");
const _1 = require(".");
exports.DATE_FORMAT = 'YYYY-MM-DD HH:mm:ss.SSS';
const ID = '_id';
function isInternalFieldPath(path) {
    return typeof path === 'string' && /^__safeContent__($|\.)/.test(path);
}
exports.isInternalFieldPath = isInternalFieldPath;
const UNEDITABLE_TYPES = [
    'Binary',
    'Code',
    'MinKey',
    'MaxKey',
    'Timestamp',
    'BSONRegExp',
    'Undefined',
    'Null',
    'DBRef',
];
class Element extends eventemitter3_1.default {
    cancel() {
        if (this.elements) {
            for (const element of Array.from(this.elements)) {
                element.cancel();
            }
        }
        if (this.isModified()) {
            this.revert();
        }
    }
    constructor(key, value, parent = null, added = false) {
        super();
        this.expanded = false;
        this.uuid = new bson_1.UUID().toHexString();
        this.key = key;
        this.currentKey = key;
        this.parent = parent;
        this.added = added;
        this.removed = false;
        this.type = hadron_type_checker_1.default.type(value);
        this.currentType = this.type;
        this.level = this._getLevel();
        this.setValid();
        if (typeof value === 'number') {
            value = hadron_type_checker_1.default.cast(value, hadron_type_checker_1.default.type(value));
        }
        if (this._isExpandable(value)) {
            this.originalExpandableValue = value;
            this.elements = this._generateElements(value);
        }
        else {
            this.value = value;
            this.currentValue = value;
        }
        let parentValue;
        if (this.parent) {
            parentValue = this.parent.isRoot()
                ? this.parent.doc
                : this.parent.originalExpandableValue;
        }
        const parentDecryptedKeys = parentValue && parentValue[Symbol.for('@@mdb.decryptedKeys')];
        this.decrypted = (parentDecryptedKeys || [])
            .map(String)
            .includes(String(key));
    }
    get nextElement() {
        return this.parent?.elements?.findNext(this);
    }
    get previousElement() {
        return this.parent?.elements?.findPrevious(this);
    }
    _getLevel() {
        let level = -1;
        let parent = this.parent;
        while (parent) {
            level++;
            parent = parent.parent;
        }
        return level;
    }
    edit(value) {
        this.currentType = hadron_type_checker_1.default.type(value);
        if (this._isExpandable(value) && !this._isExpandable(this.currentValue)) {
            this.currentValue = null;
            this.elements = this._generateElements(value);
        }
        else if (!this._isExpandable(value) && this.elements) {
            this.currentValue = value;
            this.elements = undefined;
        }
        else {
            this.currentValue = value;
        }
        this.setValid();
        this._bubbleUp(element_events_1.default.Edited, this);
    }
    changeType(newType) {
        if (newType === 'Object') {
            this._convertToEmptyObject();
        }
        else if (newType === 'Array') {
            this._convertToEmptyArray();
        }
        else {
            try {
                if (newType === 'Date') {
                    const editor = new date_1.default(this);
                    editor.edit(this.generateObject());
                    editor.complete();
                }
                else {
                    this.edit(hadron_type_checker_1.default.cast(this.generateObject(), newType));
                }
            }
            catch (e) {
                this.setInvalid(this.currentValue, newType, e.message);
            }
        }
    }
    getRoot() {
        let parent = this.parent;
        while (parent?.parent) {
            parent = parent.parent;
        }
        return parent;
    }
    get(key) {
        return this.elements?.get(key);
    }
    at(i) {
        return this.elements?.at(i);
    }
    rename(key) {
        this.currentKey = key;
        this._bubbleUp(element_events_1.default.Edited, this);
    }
    generateObject(options) {
        if (this.currentType === 'Array') {
            return object_generator_1.default.generateArray(this.elements, options);
        }
        if (this.currentType === 'Object') {
            return object_generator_1.default.generate(this.elements, options);
        }
        return this.currentValue;
    }
    generateOriginalObject(options) {
        if (this.type === 'Array') {
            const originalElements = this._generateElements(this.originalExpandableValue);
            return object_generator_1.default.generateOriginalArray(originalElements, options);
        }
        if (this.type === 'Object') {
            const originalElements = this._generateElements(this.originalExpandableValue);
            return object_generator_1.default.generateOriginal(originalElements, options);
        }
        return this.value;
    }
    insertAfter(element, key, value) {
        if (!this.elements) {
            throw new Error('Cannot insert values on non-array/non-object elements');
        }
        const newElement = this.elements.insertAfter(element, key, value);
        newElement._bubbleUp(element_events_1.default.Added, newElement, this);
        return newElement;
    }
    insertEnd(key, value) {
        if (!this.elements) {
            throw new Error('Cannot insert values on non-array/non-object elements');
        }
        const newElement = this.elements.insertEnd(key, value, true);
        this._bubbleUp(element_events_1.default.Added, newElement);
        return newElement;
    }
    insertPlaceholder() {
        const placeholderValue = this.currentType === 'Array' && this.elements?.lastElement
            ? (0, utils_1.getDefaultValueForType)(this.elements?.lastElement.currentType)
            : '';
        return this.insertEnd('', placeholderValue);
    }
    insertSiblingPlaceholder() {
        const placeholderValue = this.parent?.currentType === 'Array'
            ? (0, utils_1.getDefaultValueForType)(this.currentType)
            : '';
        return this.parent.insertAfter(this, '', placeholderValue);
    }
    isAdded() {
        return this.added || !!this.parent?.isAdded();
    }
    isBlank() {
        return this.currentKey === '' && this.currentValue === '';
    }
    isCurrentTypeValid() {
        return !!this.currentTypeValid;
    }
    setValid() {
        this.currentTypeValid = true;
        this.invalidTypeMessage = undefined;
        this._bubbleUp(element_events_1.default.Valid, this);
    }
    setInvalid(value, newType, message) {
        this.currentValue = value;
        this.currentType = newType;
        this.currentTypeValid = false;
        this.invalidTypeMessage = message;
        this._bubbleUp(element_events_1.default.Invalid, this);
    }
    isDuplicateKey(value) {
        if (value === '') {
            return false;
        }
        for (const element of this.parent?.elements ?? []) {
            if (element.uuid !== this.uuid && element.currentKey === value) {
                return true;
            }
        }
        return false;
    }
    isEdited() {
        return ((this.isRenamed() ||
            !this._valuesEqual() ||
            this.type !== this.currentType) &&
            !this.isAdded());
    }
    _valuesEqual() {
        if (this.currentType === 'Date' && (0, lodash_1.isString)(this.currentValue)) {
            return (0, lodash_1.isEqual)(this.value, new Date(this.currentValue));
        }
        else if (this.currentType === 'ObjectId' && (0, lodash_1.isString)(this.currentValue)) {
            return this._isObjectIdEqual();
        }
        return (0, lodash_1.isEqual)(this.value, this.currentValue);
    }
    _isObjectIdEqual() {
        try {
            return this.value.toHexString() === this.currentValue;
        }
        catch (_) {
            return false;
        }
    }
    isLast() {
        return this.parent?.elements?.lastElement === this;
    }
    isRenamed() {
        if (!this.parent ||
            this.parent.isRoot() ||
            this.parent.currentType === 'Object') {
            return this.key !== this.currentKey;
        }
        return false;
    }
    hasChangedKey() {
        return this.key !== this.currentKey;
    }
    isRevertable() {
        return this.isEdited() || this.isRemoved();
    }
    isRemovable() {
        return !this.parent.isRemoved();
    }
    isNotActionable() {
        return (((this.key === ID || this.isInternalField()) && !this.isAdded()) ||
            !this.isRemovable());
    }
    isValueDecrypted() {
        return this.decrypted;
    }
    containsDecryptedChildren() {
        if (this.isValueDecrypted()) {
            return true;
        }
        for (const element of this.elements || []) {
            if (element.containsDecryptedChildren()) {
                return true;
            }
        }
        return false;
    }
    isValueEditable() {
        return (this._isKeyLegallyEditable() &&
            !UNEDITABLE_TYPES.includes(this.currentType));
    }
    isParentEditable() {
        if (this.parent && !this.parent.isRoot()) {
            return this.parent._isKeyLegallyEditable();
        }
        return true;
    }
    _isKeyLegallyEditable() {
        return (this.isParentEditable() &&
            (this.isAdded() ||
                ((this.currentKey !== ID || !this.parent?.isRoot()) &&
                    !this.isInternalField())));
    }
    isKeyEditable() {
        return this._isKeyLegallyEditable() && !this.containsDecryptedChildren();
    }
    isInternalField() {
        if (!this.parent) {
            return false;
        }
        if (!this.parent.isRoot() && this.parent.isInternalField()) {
            return true;
        }
        if (this.parent.isRoot() && isInternalFieldPath(this.currentKey)) {
            return true;
        }
        return false;
    }
    isModified() {
        if (this.elements) {
            for (const element of this.elements) {
                if (element.isModified()) {
                    return true;
                }
            }
        }
        return this.isAdded() || this.isEdited() || this.isRemoved();
    }
    isRemoved() {
        return this.removed;
    }
    hasAnyRemovedChild() {
        if (this.elements) {
            for (const element of this.elements) {
                if (element.isRemoved()) {
                    return true;
                }
            }
        }
        return false;
    }
    isRoot() {
        return false;
    }
    remove() {
        this.revert();
        this.removed = true;
        if (this.parent) {
            this._bubbleUp(element_events_1.default.Removed, this, this.parent);
        }
    }
    revert() {
        if (this.isAdded()) {
            this.parent?.elements?.remove(this);
            this._bubbleUp(element_events_1.default.Removed, this, this.parent);
            delete this.parent;
        }
        else {
            if (this.originalExpandableValue) {
                this.elements = this._generateElements(this.originalExpandableValue);
                this.currentValue = undefined;
            }
            else {
                if (this.currentValue === null && this.value !== null) {
                    delete this.elements;
                }
                else {
                    this._removeAddedElements();
                }
                this.currentValue = this.value;
            }
            this.currentKey = this.key;
            this.currentType = this.type;
            this.removed = false;
        }
        this.setValid();
        this._bubbleUp(element_events_1.default.Reverted, this);
    }
    expand(expandChildren = false) {
        if (!this._isExpandable(this.originalExpandableValue)) {
            return;
        }
        this.expanded = true;
        if (expandChildren && this.elements) {
            for (const element of this.elements) {
                element.expand(expandChildren);
            }
        }
        this.emit(_1.ElementEvents.Expanded, this);
    }
    collapse() {
        if (!this._isExpandable(this.originalExpandableValue)) {
            return;
        }
        this.expanded = false;
        if (this.elements) {
            for (const element of this.elements) {
                element.collapse();
            }
        }
        this.emit(_1.ElementEvents.Collapsed, this);
    }
    _bubbleUp(evt, ...data) {
        this.emit(evt, ...data);
        const element = this.parent;
        if (element) {
            if (element.isRoot()) {
                element.emit(evt, ...data);
            }
            else {
                element._bubbleUp(evt, ...data);
            }
        }
    }
    _convertToEmptyObject() {
        this.edit({});
        this.insertPlaceholder();
    }
    _convertToEmptyArray() {
        this.edit([]);
        this.insertPlaceholder();
    }
    _isElementEmpty(element) {
        return !!element && element.isAdded() && element.isBlank();
    }
    _isExpandable(value) {
        return (0, lodash_1.isPlainObject)(value) || (0, lodash_1.isArray)(value);
    }
    _generateElements(object) {
        return new ElementList(this, object);
    }
    _removeAddedElements() {
        if (this.elements) {
            for (const element of this.elements) {
                if (element.isAdded()) {
                    this.elements.remove(element);
                }
            }
        }
    }
    static get Events() {
        return _1.ElementEvents;
    }
}
exports.Element = Element;
class ElementList {
    constructor(parent, originalDoc) {
        this.parent = parent;
        this.elements = Object.entries(originalDoc ?? {}).map(([k, v]) => {
            return new Element(this.isArray() ? parseInt(k, 10) : k, v, parent, parent.isRoot() ? parent.cloned : false);
        });
    }
    isArray() {
        return this.parent.currentType === 'Array';
    }
    get size() {
        return this.elements.length;
    }
    at(index) {
        return this.elements[index];
    }
    get(key) {
        return this.elements.find((el) => {
            return el.currentKey === key;
        });
    }
    some(predicate) {
        return this.elements.some(predicate);
    }
    every(predicate) {
        return this.elements.every(predicate);
    }
    get firstElement() {
        return this.elements[0];
    }
    get lastElement() {
        return this.elements[this.elements.length - 1];
    }
    insertAfter(afterElement, key, value, added = true) {
        let newElement;
        let newElementIdx = -1;
        for (const [idx, el] of this.elements.entries()) {
            if (afterElement === el) {
                newElementIdx = idx + 1;
                newElement = new Element(this.isArray() ? newElementIdx : key, value, this.parent, added);
                continue;
            }
            if (newElement && this.isArray()) {
                el.currentKey = idx + 1;
            }
        }
        if (newElement) {
            this.elements.splice(newElementIdx, 0, newElement);
        }
        return newElement;
    }
    insertBefore(beforeElement, key, value, added = true) {
        let newElement;
        let newElementIdx = -1;
        for (const [idx, el] of this.elements.entries()) {
            if (beforeElement === el) {
                newElementIdx = idx;
                newElement = new Element(this.isArray() ? newElementIdx : key, value, this.parent, added);
            }
            if (newElement && this.isArray()) {
                el.currentKey = idx + 1;
            }
        }
        if (newElement) {
            this.elements.splice(newElementIdx, 0, newElement);
        }
        return newElement;
    }
    insertBeginning(key, value, added = true) {
        const newElement = new Element(this.isArray() ? 0 : key, value, this.parent, added);
        if (this.isArray()) {
            this.elements.forEach((el) => {
                el.currentKey += 1;
            });
        }
        this.elements.unshift(newElement);
        return newElement;
    }
    insertEnd(key, value, added = true) {
        const newElement = new Element(this.isArray() ? this.elements.length : key, value, this.parent, added);
        this.elements.push(newElement);
        return newElement;
    }
    remove(removeElement) {
        let removeIdx = -1;
        for (const [idx, el] of this.elements.entries()) {
            if (el === removeElement) {
                removeIdx = idx;
                continue;
            }
            if (removeIdx !== -1 && this.isArray()) {
                el.currentKey -= 1;
            }
        }
        if (removeIdx !== -1) {
            this.elements.splice(removeIdx, 1);
        }
        return this;
    }
    findNext(el) {
        const idx = this.elements.indexOf(el);
        return idx !== -1 ? this.elements[idx + 1] : undefined;
    }
    findPrevious(el) {
        const idx = this.elements.indexOf(el);
        return idx !== -1 ? this.elements[idx - 1] : undefined;
    }
    *[Symbol.iterator]() {
        yield* this.elements;
    }
}
exports.ElementList = ElementList;
exports.default = Element;
//# sourceMappingURL=element.js.map