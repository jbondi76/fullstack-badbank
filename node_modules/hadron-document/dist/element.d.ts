import EventEmitter from 'eventemitter3';
import type { ObjectGeneratorOptions } from './object-generator';
import Events from './element-events';
import type Document from './document';
import type { TypeCastTypes } from 'hadron-type-checker';
import type { BSONArray, BSONObject, BSONValue } from './utils';
import { ElementEvents } from '.';
export declare const DATE_FORMAT = "YYYY-MM-DD HH:mm:ss.SSS";
export { Events };
export declare function isInternalFieldPath(path: string | number): boolean;
export declare class Element extends EventEmitter {
    uuid: string;
    key: string | number;
    currentKey: string | number;
    value: BSONValue;
    currentValue: BSONValue;
    added: boolean;
    removed: boolean;
    elements?: ElementList;
    originalExpandableValue?: BSONObject | BSONArray;
    parent: Element | Document | null;
    type: TypeCastTypes;
    currentType: TypeCastTypes;
    level: number;
    currentTypeValid?: boolean;
    invalidTypeMessage?: string;
    decrypted: boolean;
    expanded: boolean;
    cancel(): void;
    constructor(key: string | number, value: BSONValue | number, parent?: Element | Document | null, added?: boolean);
    get nextElement(): Element | undefined;
    get previousElement(): Element | undefined;
    _getLevel(): number;
    edit(value: BSONValue): void;
    changeType(newType: TypeCastTypes): void;
    getRoot(): Document;
    get(key: string | number): Element | undefined;
    at(i: number): Element | undefined;
    rename(key: string | number): void;
    generateObject(options?: ObjectGeneratorOptions): BSONValue;
    generateOriginalObject(options?: ObjectGeneratorOptions): BSONValue;
    insertAfter(element: Element, key: string | number, value: BSONValue): Element;
    insertEnd(key: string | number, value: BSONValue): Element;
    insertPlaceholder(): Element;
    insertSiblingPlaceholder(): Element;
    isAdded(): boolean;
    isBlank(): boolean;
    isCurrentTypeValid(): boolean;
    setValid(): void;
    setInvalid(value: BSONValue, newType: TypeCastTypes, message: string): void;
    isDuplicateKey(value: string | number): boolean;
    isEdited(): boolean;
    _valuesEqual(): boolean;
    _isObjectIdEqual(): boolean;
    isLast(): boolean;
    isRenamed(): boolean;
    hasChangedKey(): boolean;
    isRevertable(): boolean;
    isRemovable(): boolean;
    isNotActionable(): boolean;
    isValueDecrypted(): boolean;
    containsDecryptedChildren(): boolean;
    isValueEditable(): boolean;
    isParentEditable(): boolean;
    _isKeyLegallyEditable(): boolean;
    isKeyEditable(): boolean;
    isInternalField(): boolean;
    isModified(): boolean;
    isRemoved(): boolean;
    hasAnyRemovedChild(): boolean;
    isRoot(): false;
    remove(): void;
    revert(): void;
    expand(expandChildren?: boolean): void;
    collapse(): void;
    _bubbleUp(evt: typeof Events[keyof typeof Events], ...data: BSONArray): void;
    _convertToEmptyObject(): void;
    _convertToEmptyArray(): void;
    _isElementEmpty(element: Element | undefined | null): boolean;
    _isExpandable(value: BSONValue): value is BSONObject | BSONArray;
    _generateElements(object: BSONObject | BSONArray): ElementList;
    _removeAddedElements(): void;
    static get Events(): typeof ElementEvents;
}
export declare class ElementList implements Iterable<Element> {
    private parent;
    private elements;
    constructor(parent: Document | Element, originalDoc: BSONObject | BSONArray | null | undefined);
    private isArray;
    get size(): number;
    at(index: number): Element | undefined;
    get(key: string | number): Element | undefined;
    some(predicate: (value: Element, index: number, array: Element[]) => unknown): boolean;
    every(predicate: (value: Element, index: number, array: Element[]) => unknown): boolean;
    get firstElement(): Element | undefined;
    get lastElement(): Element | undefined;
    insertAfter(afterElement: Element, key: string | number, value: BSONValue, added?: boolean): Element | undefined;
    insertBefore(beforeElement: Element, key: string | number, value: BSONValue, added?: boolean): Element | undefined;
    insertBeginning(key: string | number, value: BSONValue, added?: boolean): Element;
    insertEnd(key: string | number, value: BSONValue, added?: boolean): Element;
    remove(removeElement: Element): this;
    findNext(el: Element): Element | undefined;
    findPrevious(el: Element): Element | undefined;
    [Symbol.iterator](): Iterator<Element>;
}
export default Element;
//# sourceMappingURL=element.d.ts.map