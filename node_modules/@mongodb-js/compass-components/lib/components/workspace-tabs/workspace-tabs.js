"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkspaceTabs = exports.useRovingTabIndex = exports.scrollbarThumbDarkTheme = exports.scrollbarThumbLightTheme = void 0;
const react_1 = __importStar(require("react"));
const emotion_1 = require("@leafygreen-ui/emotion");
const palette_1 = require("@leafygreen-ui/palette");
const tokens_1 = require("@leafygreen-ui/tokens");
const polished_1 = require("polished");
const core_1 = require("@dnd-kit/core");
const sortable_1 = require("@dnd-kit/sortable");
const use_theme_1 = require("../../hooks/use-theme");
const use_focus_hover_1 = require("../../hooks/use-focus-hover");
const leafygreen_1 = require("../leafygreen");
const merge_props_1 = require("../../utils/merge-props");
const tab_1 = require("./tab");
const use_hotkeys_1 = require("../../hooks/use-hotkeys");
exports.scrollbarThumbLightTheme = (0, polished_1.rgba)(palette_1.palette.gray.base, 0.65);
exports.scrollbarThumbDarkTheme = (0, polished_1.rgba)(palette_1.palette.gray.base, 0.65);
const tabsContainerStyles = (0, emotion_1.css)({
    margin: 0,
    padding: 0,
    flexShrink: 0,
    position: 'relative',
    overflow: 'overlay',
    whiteSpace: 'nowrap',
    '::-webkit-scrollbar': {
        ':horizontal': {
            height: tokens_1.spacing[1],
        },
    },
    minHeight: 36,
});
const tabsContainerLightStyles = (0, emotion_1.css)({
    background: palette_1.palette.gray.light3,
    boxShadow: `inset 0px -1px 0 0 ${palette_1.palette.gray.light2}`,
    '::-webkit-scrollbar-thumb': {
        backgroundColor: exports.scrollbarThumbLightTheme,
    },
});
const tabsContainerDarkStyles = (0, emotion_1.css)({
    backgroundColor: palette_1.palette.gray.dark3,
    boxShadow: `inset 0px -1px 0 0 ${palette_1.palette.gray.dark2}`,
    '::-webkit-scrollbar-thumb': {
        backgroundColor: exports.scrollbarThumbDarkTheme,
    },
});
const tabsListContainerStyles = (0, emotion_1.css)({
    display: 'flex',
    flexDirection: 'row',
});
const tabsListStyles = (0, emotion_1.css)({
    display: 'inline-flex',
});
const newTabContainerStyles = (0, emotion_1.css)({
    flex: 'none',
    alignSelf: 'center',
});
const createNewTabButtonStyles = (0, emotion_1.css)({
    margin: tokens_1.spacing[1],
});
const sortableItemContainerStyles = (0, emotion_1.css)({
    display: 'inline-flex',
});
function useTabListKeyboardNavigation({ tabsCount, onSelectTab, selectedTabIndex, }) {
    const onKeyDown = (0, react_1.useCallback)((evt) => {
        let nextTabbable = -1;
        if (evt.key === 'ArrowLeft') {
            evt.stopPropagation();
            nextTabbable = selectedTabIndex - 1;
        }
        if (evt.key === 'ArrowRight') {
            evt.stopPropagation();
            nextTabbable = selectedTabIndex + 1;
        }
        if (evt.key === 'Home') {
            evt.preventDefault();
            evt.stopPropagation();
            nextTabbable = 0;
        }
        if (evt.key === 'End') {
            evt.preventDefault();
            evt.stopPropagation();
            nextTabbable = tabsCount - 1;
        }
        if (tabsCount > 0 &&
            nextTabbable !== selectedTabIndex &&
            nextTabbable >= 0 &&
            nextTabbable < tabsCount) {
            onSelectTab(nextTabbable);
        }
    }, [selectedTabIndex, tabsCount, onSelectTab]);
    return [{ onKeyDown }];
}
function useRovingTabIndex({ currentTabbable, }) {
    const rootNode = (0, react_1.useRef)(null);
    const [focusProps, focusState] = (0, use_focus_hover_1.useFocusState)();
    const focusTabbable = (0, react_1.useCallback)(() => {
        const selector = `[role="tab"]:nth-child(${currentTabbable + 1})`;
        rootNode.current?.querySelector(selector)?.focus();
    }, [rootNode, currentTabbable]);
    (0, react_1.useEffect)(() => {
        if ([
            use_focus_hover_1.FocusState.Focus,
            use_focus_hover_1.FocusState.FocusVisible,
            use_focus_hover_1.FocusState.FocusWithin,
            use_focus_hover_1.FocusState.FocusWithinVisible,
        ].includes(focusState)) {
            focusTabbable();
        }
    }, [focusState, focusTabbable]);
    return { ref: rootNode, ...focusProps };
}
exports.useRovingTabIndex = useRovingTabIndex;
const SortableList = ({ tabs, onMove, onSelect, selectedTabIndex, onClose, }) => {
    const items = tabs.map((tab) => tab.id);
    const [activeId, setActiveId] = (0, react_1.useState)(null);
    const sensors = (0, core_1.useSensors)((0, core_1.useSensor)(core_1.MouseSensor, {
        activationConstraint: {
            distance: 10,
        },
    }), (0, core_1.useSensor)(core_1.TouchSensor, {
        activationConstraint: {
            delay: 250,
            tolerance: 5,
        },
    }));
    const onSortEnd = (0, react_1.useCallback)(({ oldIndex, newIndex }) => {
        const from = tabs.findIndex((tab) => tab.id === oldIndex);
        const to = tabs.findIndex((tab) => tab.id === newIndex);
        onMove(from, to);
    }, [onMove, tabs]);
    return (react_1.default.createElement(core_1.DndContext, { sensors: sensors, autoScroll: false, onDragStart: ({ active }) => {
            if (!active) {
                return;
            }
            setActiveId(active.id);
        }, onDragEnd: ({ active, over }) => {
            setActiveId(null);
            if (over && active.id !== over.id) {
                onSortEnd({ oldIndex: active.id, newIndex: over.id });
            }
        }, onDragCancel: () => setActiveId(null) },
        react_1.default.createElement(sortable_1.SortableContext, { items: items, strategy: sortable_1.horizontalListSortingStrategy },
            react_1.default.createElement("div", { className: sortableItemContainerStyles }, tabs.map((tab, index) => (react_1.default.createElement(SortableItem, { key: tab.id, index: index, tab: tab, activeId: activeId, onSelect: onSelect, onClose: onClose, selectedTabIndex: selectedTabIndex })))))));
};
const SortableItem = ({ tab: tabProps, index, selectedTabIndex, activeId, onSelect, onClose, }) => {
    const { id: tabId } = tabProps;
    const onTabSelected = (0, react_1.useCallback)(() => {
        onSelect(index);
    }, [onSelect, index]);
    const onTabClosed = (0, react_1.useCallback)(() => {
        onClose(index);
    }, [onClose, index]);
    const isSelected = (0, react_1.useMemo)(() => selectedTabIndex === index, [selectedTabIndex, index]);
    const isDragging = (0, react_1.useMemo)(() => tabId === activeId, [tabId, activeId]);
    return (react_1.default.createElement(tab_1.Tab, { ...tabProps, isSelected: isSelected, isDragging: isDragging, tabContentId: tabId, onSelect: onTabSelected, onClose: onTabClosed }));
};
function WorkspaceTabs({ ['aria-label']: ariaLabel, onCreateNewTab, onCloseTab, onMoveTab, onSelectTab, onSelectNextTab, onSelectPrevTab, tabs, selectedTabIndex, }) {
    const darkMode = (0, use_theme_1.useDarkMode)();
    const rovingFocusProps = useRovingTabIndex({
        currentTabbable: selectedTabIndex,
    });
    const [navigationProps] = useTabListKeyboardNavigation({
        selectedTabIndex,
        onSelectTab,
        tabsCount: tabs.length,
    });
    const tabContainerProps = (0, merge_props_1.mergeProps)(rovingFocusProps, navigationProps);
    (0, use_hotkeys_1.useHotkeys)('ctrl + tab', (e) => {
        e.preventDefault();
        e.stopPropagation();
        onSelectNextTab();
    }, [onSelectNextTab]);
    (0, use_hotkeys_1.useHotkeys)('ctrl + shift + tab', (e) => {
        e.preventDefault();
        e.stopPropagation();
        onSelectPrevTab();
    }, [onSelectPrevTab]);
    (0, use_hotkeys_1.useHotkeys)('mod + shift + ]', (e) => {
        e.preventDefault();
        e.stopPropagation();
        onSelectNextTab();
    }, [onSelectNextTab]);
    (0, use_hotkeys_1.useHotkeys)('mod + shift + [', (e) => {
        e.preventDefault();
        e.stopPropagation();
        onSelectPrevTab();
    }, [onSelectPrevTab]);
    (0, use_hotkeys_1.useHotkeys)('mod + w', (e) => {
        e.preventDefault();
        e.stopPropagation();
        onCloseTab(selectedTabIndex);
    }, [onCloseTab, selectedTabIndex]);
    (0, use_hotkeys_1.useHotkeys)('mod + t', (e) => {
        e.preventDefault();
        e.stopPropagation();
        onCreateNewTab();
    }, [onCreateNewTab]);
    return (react_1.default.createElement("div", { className: (0, emotion_1.cx)(tabsContainerStyles, darkMode ? tabsContainerDarkStyles : tabsContainerLightStyles) },
        react_1.default.createElement("div", { className: tabsListContainerStyles },
            react_1.default.createElement("div", { className: tabsListStyles, role: "tablist", "aria-label": ariaLabel, "aria-orientation": "horizontal", ...tabContainerProps },
                react_1.default.createElement(SortableList, { tabs: tabs, onMove: onMoveTab, onSelect: onSelectTab, onClose: onCloseTab, selectedTabIndex: selectedTabIndex })),
            react_1.default.createElement("div", { className: newTabContainerStyles },
                react_1.default.createElement(leafygreen_1.IconButton, { className: createNewTabButtonStyles, "aria-label": "Create new tab", onClick: onCreateNewTab },
                    react_1.default.createElement(leafygreen_1.Icon, { role: "presentation", glyph: "Plus" }))))));
}
exports.WorkspaceTabs = WorkspaceTabs;
//# sourceMappingURL=workspace-tabs.js.map