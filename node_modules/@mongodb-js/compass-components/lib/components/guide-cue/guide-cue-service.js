"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.guideCueService = exports.GuideCueService = void 0;
const guide_cue_exceptions_1 = require("./guide-cue-exceptions");
const guide_cue_groups_1 = require("./guide-cue-groups");
const guide_cue_storage_1 = require("./guide-cue-storage");
const lodash_1 = require("lodash");
class GuideCueService extends EventTarget {
    constructor(_storage) {
        super();
        this._storage = _storage;
        this._cues = [];
        this._activeGroupId = null;
        this._activeCue = null;
    }
    addCue(cue) {
        if (process.env.DISABLE_GUIDE_CUES === 'true') {
            return;
        }
        const cueIndex = this.getCueIndex(cue.cueId, cue.groupId);
        if (cueIndex !== -1) {
            console.warn(`The Cue ${cue.cueId} is already added.`);
            return;
        }
        if (cue.groupId) {
            this.validateCueData(cue.groupId, cue.step);
        }
        this._cues.push({
            ...cue,
            isVisited: this._storage.isCueVisited(cue.cueId, cue.groupId),
        });
        if (!this._activeCue) {
            return this.onNext();
        }
        return this.dispatchShowCueEvent();
    }
    dispatchShowCueEvent() {
        if (!this._activeCue) {
            return;
        }
        try {
            return this.dispatchEvent(new CustomEvent('show-cue', {
                detail: {
                    cueId: this._activeCue.cueId,
                    groupId: this._activeCue.groupId,
                },
            }));
        }
        catch (ex) {
        }
    }
    validateCueData(groupId, step) {
        if (!guide_cue_groups_1.GROUP_STEPS_MAP.has(groupId)) {
            throw new guide_cue_exceptions_1.UnregisteredGroupError(groupId);
        }
        const groupCues = this._cues.filter((x) => x.groupId === groupId);
        const groupSteps = guide_cue_groups_1.GROUP_STEPS_MAP.get(groupId);
        if (groupCues.length >= groupSteps) {
            throw new guide_cue_exceptions_1.GroupStepsCompleteError(groupId, groupSteps);
        }
        if (step > groupSteps) {
            throw new guide_cue_exceptions_1.InvalidCueStepError(groupId, groupSteps, step);
        }
        if (groupCues.find((x) => x.step === step)) {
            throw new guide_cue_exceptions_1.DuplicateCueStepError(groupId, step);
        }
    }
    removeCue(cueId, groupId) {
        const cueIndex = this._cues.findIndex((cue) => cue.cueId === cueId && cue.groupId === groupId);
        if (cueIndex === -1) {
            return;
        }
        this._cues.splice(cueIndex, 1);
        if (this._activeCue?.cueId === cueId &&
            this._activeCue.groupId === groupId) {
            this._activeCue = null;
        }
    }
    onNext() {
        this._activeCue = this.findNextCue();
        return this.dispatchShowCueEvent();
    }
    getCountOfSteps(groupId) {
        return !groupId
            ? 1
            : this._cues.filter((x) => x.groupId === groupId).length || 1;
    }
    findNextCue() {
        if (this._activeGroupId) {
            const nextCue = this.getNextCueFromGroup(this._activeGroupId);
            if (nextCue) {
                return nextCue;
            }
        }
        const nextCue = this.getNextCueFromNextGroup();
        this._activeGroupId = nextCue?.groupId || null;
        return nextCue;
    }
    getNextCueFromGroup(groupId) {
        const groupCues = this._cues.filter((x) => x.groupId === groupId);
        if (groupCues.length !== guide_cue_groups_1.GROUP_STEPS_MAP.get(groupId)) {
            return null;
        }
        const unseenCues = groupCues.filter((x) => !x.isVisited && x.isIntersecting);
        if (unseenCues.length === 0) {
            return null;
        }
        unseenCues.sort((a, b) => a.step - b.step);
        return unseenCues[0];
    }
    getNextCueFromNextGroup() {
        let nextPossibleIndex = 0;
        while (nextPossibleIndex < this._cues.length) {
            const cue = this._cues[nextPossibleIndex];
            if (!cue.groupId) {
                if (!cue.isVisited && cue.isIntersecting) {
                    return cue;
                }
            }
            else {
                const nextCue = this.getNextCueFromGroup(cue.groupId);
                if (nextCue) {
                    return nextCue;
                }
            }
            nextPossibleIndex++;
        }
        return null;
    }
    getCueIndex(cueId, groupId) {
        return this._cues.findIndex((cue) => cue.cueId === cueId && cue.groupId === groupId);
    }
    markCueAsVisited(cueId, groupId) {
        const cueIndex = this.getCueIndex(cueId, groupId);
        if (cueIndex === -1) {
            return;
        }
        this._cues[cueIndex].isVisited = true;
        this._storage.markCueAsVisited(cueId, groupId);
        this._activeCue = null;
    }
    markGroupAsVisited(groupId) {
        const groupCues = this._cues.filter((x) => x.groupId === groupId);
        if (groupCues.length === guide_cue_groups_1.GROUP_STEPS_MAP.get(groupId)) {
            groupCues.forEach(({ cueId }) => {
                this.markCueAsVisited(cueId, groupId);
            });
        }
        this._activeGroupId = null;
        this._activeCue = null;
    }
    markAllCuesAsVisited() {
        this._cues
            .filter((x) => !x.groupId)
            .forEach(({ cueId, groupId }) => {
            this.markCueAsVisited(cueId, groupId);
        });
        const groupIds = (0, lodash_1.uniq)(this._cues.map((x) => x.groupId)).filter(Boolean);
        groupIds.forEach((groupId) => this.markGroupAsVisited(groupId));
    }
    onCueIntersectionChange(isIntersecting, cueId, groupId) {
        const cueIndex = this.getCueIndex(cueId, groupId);
        if (cueIndex === -1) {
            return;
        }
        this._cues[cueIndex].isIntersecting = isIntersecting;
        const isNewCueShowable = !this._activeCue && isIntersecting;
        const isActiveCueNotShowable = this._activeCue?.cueId === cueId &&
            this._activeCue.groupId === groupId &&
            !isIntersecting;
        if (isActiveCueNotShowable || isNewCueShowable) {
            return this.onNext();
        }
    }
}
exports.GuideCueService = GuideCueService;
exports.guideCueService = new GuideCueService(new guide_cue_storage_1.CompassGuideCueStorage());
//# sourceMappingURL=guide-cue-service.js.map