"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HadronElement = void 0;
const react_1 = __importStar(require("react"));
const hadron_document_1 = require("hadron-document");
const bson_value_1 = __importDefault(require("../bson-value"));
const tokens_1 = require("@leafygreen-ui/tokens");
const element_editors_1 = require("./element-editors");
const element_actions_1 = require("./element-actions");
const auto_focus_context_1 = require("./auto-focus-context");
const use_force_update_1 = require("./use-force-update");
const use_previous_1 = require("./use-previous");
const emotion_1 = require("@leafygreen-ui/emotion");
const palette_1 = require("@leafygreen-ui/palette");
const leafygreen_1 = require("../leafygreen");
const use_theme_1 = require("../../hooks/use-theme");
function getEditorByType(type) {
    switch (type) {
        case 'Date':
        case 'String':
        case 'Decimal128':
        case 'Double':
        case 'Int32':
        case 'Int64':
        case 'Null':
        case 'Undefined':
        case 'ObjectId':
            return hadron_document_1.ElementEditor[`${type}Editor`];
        default:
            return hadron_document_1.ElementEditor.StandardEditor;
    }
}
function useElementEditor(el) {
    const editor = (0, react_1.useRef)(null);
    if (!editor.current ||
        editor.current?.element !== el ||
        editor.current?.type !== el.currentType) {
        const Editor = getEditorByType(el.currentType);
        editor.current = new Editor(el);
    }
    return editor.current;
}
function useHadronElement(el) {
    const forceUpdate = (0, use_force_update_1.useForceUpdate)();
    const prevEl = (0, use_previous_1.usePrevious)(el);
    const editor = useElementEditor(el);
    const [isDuplicateKey, setIsDuplicateKey] = (0, react_1.useState)(() => {
        return el.isDuplicateKey(el.currentKey);
    });
    const onElementChanged = (0, react_1.useCallback)((changedElement) => {
        if (el.uuid === changedElement.uuid) {
            forceUpdate();
        }
    }, [el, forceUpdate]);
    const onElementAddedOrRemoved = (0, react_1.useCallback)((_el, parentEl) => {
        if (el === parentEl) {
            forceUpdate();
        }
    }, [el, forceUpdate]);
    (0, react_1.useEffect)(() => {
        if (prevEl && prevEl !== el) {
            forceUpdate();
        }
    }, [el, prevEl, forceUpdate]);
    (0, react_1.useEffect)(() => {
        el.on(hadron_document_1.ElementEvents.Converted, onElementChanged);
        el.on(hadron_document_1.ElementEvents.Edited, onElementChanged);
        el.on(hadron_document_1.ElementEvents.Reverted, onElementChanged);
        el.on(hadron_document_1.ElementEvents.Invalid, onElementChanged);
        el.on(hadron_document_1.ElementEvents.Valid, onElementChanged);
        el.on(hadron_document_1.ElementEvents.Added, onElementAddedOrRemoved);
        el.on(hadron_document_1.ElementEvents.Removed, onElementAddedOrRemoved);
        el.on(hadron_document_1.ElementEvents.Expanded, onElementChanged);
        el.on(hadron_document_1.ElementEvents.Collapsed, onElementChanged);
        return () => {
            el.off(hadron_document_1.ElementEvents.Converted, onElementChanged);
            el.off(hadron_document_1.ElementEvents.Edited, onElementChanged);
            el.off(hadron_document_1.ElementEvents.Reverted, onElementChanged);
            el.off(hadron_document_1.ElementEvents.Valid, onElementChanged);
            el.off(hadron_document_1.ElementEvents.Added, onElementAddedOrRemoved);
            el.off(hadron_document_1.ElementEvents.Removed, onElementAddedOrRemoved);
            el.off(hadron_document_1.ElementEvents.Expanded, onElementChanged);
            el.off(hadron_document_1.ElementEvents.Collapsed, onElementChanged);
        };
    }, [el, onElementChanged, onElementAddedOrRemoved]);
    const isValid = el.isCurrentTypeValid();
    return {
        id: el.uuid,
        key: {
            value: String(el.currentKey),
            change(newVal) {
                setIsDuplicateKey(el.isDuplicateKey(newVal));
                el.rename(newVal);
            },
            editable: el.isKeyEditable() && el.parent?.currentType !== 'Array',
            valid: !isDuplicateKey,
            validationMessage: isDuplicateKey
                ? `Duplicate key "${el.currentKey}" - this will overwrite previous values`
                : null,
        },
        value: {
            value: editor.value(),
            originalValue: el.currentType === 'Array' ? [...(el.elements || [])] : el.currentValue,
            change(newVal) {
                editor.edit(newVal);
            },
            editable: el.isValueEditable() &&
                el.currentType !== 'Object' &&
                el.currentType !== 'Array',
            decrypted: el.isValueDecrypted(),
            valid: isValid,
            validationMessage: !isValid ? el.invalidTypeMessage ?? null : null,
            startEdit: editor.start.bind(editor),
            completeEdit: editor.complete.bind(editor),
        },
        type: {
            value: el.currentType,
            change(newVal) {
                el.changeType(newVal);
            },
        },
        revert: el.isRevertable() ? el.revert.bind(el) : null,
        remove: el.isNotActionable() ? null : el.remove.bind(el),
        expandable: Boolean(el.elements),
        children: el.elements ? [...el.elements] : [],
        level: el.level,
        parentType: el.parent?.currentType,
        removed: el.isRemoved(),
        internal: el.isInternalField(),
        expanded: el.expanded,
        expand: el.expand.bind(el),
        collapse: el.collapse.bind(el),
    };
}
const expandButton = (0, emotion_1.css)({
    margin: 0,
    padding: 0,
    border: 'none',
    background: 'none',
    '&:hover': {
        cursor: 'pointer',
    },
    display: 'flex',
});
const hadronElement = (0, emotion_1.css)({
    display: 'flex',
    paddingLeft: tokens_1.spacing[2],
    paddingRight: tokens_1.spacing[2],
    marginTop: 1,
});
const hadronElementLightMode = (0, emotion_1.css)({
    '&:hover': {
        backgroundColor: palette_1.palette.gray.light2,
    },
});
const hadronElementDarkMode = (0, emotion_1.css)({
    '&:hover': {
        backgroundColor: palette_1.palette.gray.dark4,
    },
});
const elementInvalidLightMode = (0, emotion_1.css)({
    backgroundColor: palette_1.palette.yellow.light3,
    '&:hover': {
        backgroundColor: palette_1.palette.yellow.light2,
    },
});
const elementRemovedLightMode = (0, emotion_1.css)({
    backgroundColor: palette_1.palette.red.light3,
    '&:hover': {
        backgroundColor: palette_1.palette.red.light2,
    },
});
const elementInvalidDarkMode = (0, emotion_1.css)({
    backgroundColor: palette_1.palette.yellow.dark3,
    '&:hover': {
        backgroundColor: palette_1.palette.yellow.dark2,
    },
});
const elementRemovedDarkMode = (0, emotion_1.css)({
    backgroundColor: palette_1.palette.red.dark3,
    '&:hover': {
        backgroundColor: palette_1.palette.red.dark2,
    },
});
const elementActions = (0, emotion_1.css)({
    flex: 'none',
    width: tokens_1.spacing[3],
    position: 'relative',
});
const elementLineNumber = (0, emotion_1.css)({
    flex: 'none',
    position: 'relative',
    marginLeft: tokens_1.spacing[1],
    boxSizing: 'content-box',
});
const addFieldActionsContainer = (0, emotion_1.css)({
    position: 'absolute',
    top: 0,
    right: 0,
});
const lineNumberCount = (0, emotion_1.css)({
    '&::before': {
        display: 'block',
        width: '100%',
        counterIncrement: 'line-number',
        content: 'counter(line-number)',
        textAlign: 'end',
        color: palette_1.palette.gray.base,
    },
});
const lineNumberInvalidLightMode = (0, emotion_1.css)({
    backgroundColor: palette_1.palette.yellow.base,
    '&::before': {
        color: palette_1.palette.yellow.dark2,
    },
});
const lineNumberRemovedLightMode = (0, emotion_1.css)({
    backgroundColor: palette_1.palette.red.base,
    color: palette_1.palette.red.light3,
    '&::before': {
        color: palette_1.palette.red.light3,
    },
});
const lineNumberInvalidDarkMode = (0, emotion_1.css)({
    backgroundColor: palette_1.palette.yellow.dark2,
    '&::before': {
        color: palette_1.palette.yellow.base,
    },
});
const lineNumberRemovedDarkMode = (0, emotion_1.css)({
    backgroundColor: palette_1.palette.red.light3,
    color: palette_1.palette.red.base,
    '&::before': {
        color: palette_1.palette.red.base,
    },
});
const elementSpacer = (0, emotion_1.css)({
    flex: 'none',
});
const elementExpand = (0, emotion_1.css)({
    width: tokens_1.spacing[3],
    flex: 'none',
    display: 'flex',
    alignItems: 'center',
});
const elementKey = (0, emotion_1.css)({
    flex: 'none',
    fontWeight: 'bold',
    maxWidth: '60%',
});
const elementKeyInternal = (0, emotion_1.css)({
    color: palette_1.palette.gray.base,
});
const elementDivider = (0, emotion_1.css)({
    flex: 'none',
    userSelect: 'none',
});
const elementValue = (0, emotion_1.css)({
    flex: 1,
    minWidth: 0,
    maxWidth: '100%',
});
const elementType = (0, emotion_1.css)({
    flex: 'none',
    marginLeft: tokens_1.spacing[1],
});
const actions = (0, emotion_1.css)({
    display: 'none',
});
const actionsVisible = (0, emotion_1.css)({
    '[data-document-element="true"]:hover &, [data-document-element="true"]:focus-within &': {
        display: 'block',
    },
});
const lineNumberCountHidden = (0, emotion_1.css)({
    '[data-document-element="true"]:hover &::before, [data-document-element="true"]:focus-within &::before': {
        visibility: 'hidden',
    },
});
const elementKeyDarkMode = (0, emotion_1.css)({
    color: palette_1.palette.gray.light2,
});
const HadronElement = ({ value: element, editable, editingEnabled, onEditStart, lineNumberSize, onAddElement, }) => {
    const darkMode = (0, use_theme_1.useDarkMode)();
    const autoFocus = (0, auto_focus_context_1.useAutoFocusContext)();
    const { id, key, value, type, revert, remove, expandable, children, level, parentType, removed, internal, expanded, expand, collapse, } = useHadronElement(element);
    const toggleExpanded = () => {
        expanded ? collapse() : expand();
    };
    const lineNumberMinWidth = (0, react_1.useMemo)(() => {
        if (editingEnabled) {
            const charCount = String(lineNumberSize).length;
            return charCount > 2 ? `${charCount}.5ch` : tokens_1.spacing[3];
        }
        return tokens_1.spacing[3];
    }, [lineNumberSize, editingEnabled]);
    const isValid = key.valid && value.valid;
    const shouldShowActions = editingEnabled;
    const elementRemoved = darkMode
        ? elementRemovedDarkMode
        : elementRemovedLightMode;
    const elementInvalid = darkMode
        ? elementInvalidDarkMode
        : elementInvalidLightMode;
    const elementProps = {
        className: (0, emotion_1.cx)(hadronElement, darkMode ? hadronElementDarkMode : hadronElementLightMode, removed ? elementRemoved : editingEnabled && !isValid && elementInvalid),
        onClick: toggleExpanded,
    };
    const keyProps = {
        className: (0, emotion_1.cx)(elementKey, internal && elementKeyInternal, darkMode && elementKeyDarkMode),
    };
    const lineNumberRemoved = darkMode
        ? lineNumberRemovedDarkMode
        : lineNumberRemovedLightMode;
    const lineNumberInvalid = darkMode
        ? lineNumberInvalidDarkMode
        : lineNumberInvalidLightMode;
    return (react_1.default.createElement(react_1.default.Fragment, null,
        react_1.default.createElement("div", { "data-document-element": "true", "data-testid": "hadron-document-element", "data-field": key.value, "data-id": element.uuid, ...elementProps },
            editable && (react_1.default.createElement("div", { className: elementActions },
                react_1.default.createElement("div", { className: (0, emotion_1.cx)(actions, shouldShowActions && actionsVisible) },
                    react_1.default.createElement(element_actions_1.EditActions, { onRevert: revert, onRemove: remove, editing: editingEnabled })))),
            editable && (react_1.default.createElement("div", { className: (0, emotion_1.cx)(elementLineNumber, editingEnabled && lineNumberCount, shouldShowActions && lineNumberCountHidden, removed
                    ? lineNumberRemoved
                    : editingEnabled && !isValid && lineNumberInvalid), style: { minWidth: lineNumberMinWidth } },
                react_1.default.createElement("div", { className: (0, emotion_1.cx)(actions, addFieldActionsContainer, shouldShowActions && actionsVisible) },
                    react_1.default.createElement(element_actions_1.AddFieldActions, { editing: editingEnabled, type: type.value, parentType: parentType && parentType === 'Document'
                            ? 'Object'
                            : parentType, keyName: key.value, onAddFieldAfterElement: () => {
                            const el = element.insertSiblingPlaceholder();
                            onAddElement(el);
                        }, onAddFieldToElement: type.value === 'Object' || type.value === 'Array'
                            ? () => {
                                const el = element.insertPlaceholder();
                                onAddElement(el);
                                expand();
                            }
                            : undefined })))),
            react_1.default.createElement("div", { className: elementSpacer, style: { width: (editable ? tokens_1.spacing[2] : 0) + tokens_1.spacing[3] * level } }),
            react_1.default.createElement("div", { className: elementExpand }, expandable && (react_1.default.createElement("button", { type: "button", className: expandButton, "aria-pressed": expanded, "aria-label": expanded ? 'Collapse field items' : 'Expand field items', onClick: (evt) => {
                    evt.stopPropagation();
                    toggleExpanded();
                } },
                react_1.default.createElement(leafygreen_1.Icon, { size: "xsmall", glyph: expanded ? 'CaretDown' : 'CaretRight' })))),
            react_1.default.createElement("div", { ...keyProps, "data-testid": "hadron-document-element-key" }, key.editable ? (react_1.default.createElement(element_editors_1.KeyEditor, { value: key.value, valid: key.valid, validationMessage: key.validationMessage, onChange: (newVal) => {
                    key.change(newVal);
                }, autoFocus: autoFocus?.id === id && autoFocus.type === 'key', editing: editingEnabled, onEditStart: () => {
                    onEditStart?.(element.uuid, 'key');
                } })) : (react_1.default.createElement("span", null, key.value))),
            react_1.default.createElement("div", { className: elementDivider, role: "presentation" }, ":\u00A0"),
            react_1.default.createElement("div", { className: elementDivider, role: "presentation" }, value.decrypted && (react_1.default.createElement("span", { "data-testid": "hadron-document-element-decrypted-icon", title: "Encrypted Field" },
                react_1.default.createElement(leafygreen_1.Icon, { glyph: "Key", size: "small" })))),
            react_1.default.createElement("div", { className: elementValue, "data-testid": "hadron-document-element-value" }, value.editable ? (react_1.default.createElement(element_editors_1.ValueEditor, { type: type.value, originalValue: value.originalValue, value: value.value, valid: value.valid, validationMessage: value.validationMessage, onChange: (newVal) => {
                    value.change(newVal);
                }, autoFocus: autoFocus?.id === id && autoFocus.type === 'value', editing: editingEnabled, onEditStart: () => {
                    onEditStart?.(element.uuid, 'value');
                }, onFocus: () => {
                    value.startEdit();
                }, onBlur: () => {
                    value.completeEdit();
                } })) : (react_1.default.createElement("div", { "data-testid": editable && !editingEnabled
                    ? 'hadron-document-clickable-value'
                    : undefined, onDoubleClick: () => {
                    if (editable && !editingEnabled) {
                        onEditStart?.(element.uuid, 'type');
                    }
                } },
                react_1.default.createElement(bson_value_1.default, { type: type.value, value: value.originalValue })))),
            editable && (react_1.default.createElement("div", { className: elementType, "data-testid": "hadron-document-element-type" },
                react_1.default.createElement(element_editors_1.TypeEditor, { editing: editingEnabled, type: type.value, autoFocus: autoFocus?.id === id && autoFocus.type === 'type', onChange: (newType) => {
                        type.change(newType);
                        if (newType === 'Array' || newType === 'Object') {
                            expand();
                        }
                    } })))),
        expandable &&
            expanded &&
            children.map((el, idx) => {
                return (react_1.default.createElement(exports.HadronElement, { key: idx, value: el, editable: editable, editingEnabled: editingEnabled, onEditStart: onEditStart, lineNumberSize: lineNumberSize, onAddElement: onAddElement }));
            })));
};
exports.HadronElement = HadronElement;
//# sourceMappingURL=element.js.map