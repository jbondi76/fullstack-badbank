"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const hadron_document_1 = require("hadron-document");
const leafygreen_1 = require("../leafygreen");
const emotion_1 = require("@leafygreen-ui/emotion");
const palette_1 = require("@leafygreen-ui/palette");
const tokens_1 = require("@leafygreen-ui/tokens");
const use_theme_1 = require("../../hooks/use-theme");
function isDeleting(status) {
    return ['Deleting', 'DeleteStart', 'DeleteSuccess', 'DeleteError'].includes(status);
}
function isSuccess(status) {
    return ['DeleteSuccess', 'UpdateSuccess'].includes(status);
}
function isPrimaryActionDisabled(status) {
    return [
        'Editing',
        'ContainsErrors',
        'UpdateStart',
        'UpdateSuccess',
        'DeleteStart',
        'DeleteSuccess',
    ].includes(status);
}
function isCancelDisabled(status) {
    return [
        'UpdateStart',
        'UpdateSuccess',
        'DeleteStart',
        'DeleteSuccess',
    ].includes(status);
}
const StatusMessages = {
    ['Initial']: '',
    ['Editing']: '',
    ['Deleting']: 'Document flagged for deletion.',
    ['Modified']: 'Document modified.',
    ['ContainsErrors']: 'Update not permitted while document contains errors.',
    ['UpdateStart']: 'Updating document…',
    ['UpdateError']: '',
    ['UpdateBlocked']: 'Document was modified in the background or it longer exists. Do you wish to continue and possibly overwrite new changes?',
    ['UpdateSuccess']: 'Document updated.',
    ['DeleteStart']: 'Removing document…',
    ['DeleteError']: '',
    ['DeleteSuccess']: 'Document deleted.',
};
function useHadronDocumentStatus(doc, editing, deleting) {
    const [status, setStatus] = (0, react_1.useState)(() => {
        return editing
            ? doc.isModified()
                ? 'Modified'
                : 'Editing'
            : deleting
                ? 'Deleting'
                : 'Initial';
    });
    const [errorMessage, setErrorMessage] = (0, react_1.useState)(null);
    const invalidElementsRef = (0, react_1.useRef)(new Set());
    const updateStatus = (0, react_1.useCallback)((newStatus, errorMessage = null) => {
        setStatus(newStatus);
        setErrorMessage(errorMessage);
    }, []);
    (0, react_1.useEffect)(() => {
        if (status !== 'Initial') {
            return;
        }
        if (editing) {
            updateStatus('Editing');
        }
        else if (deleting) {
            updateStatus('Deleting');
        }
    }, [status, updateStatus, editing, deleting]);
    (0, react_1.useEffect)(() => {
        const onUpdate = () => {
            updateStatus(invalidElementsRef.current.size === 0
                ? doc.isModified()
                    ? 'Modified'
                    : 'Editing'
                : 'ContainsErrors');
        };
        const onElementValid = (el) => {
            invalidElementsRef.current.delete(el);
            onUpdate();
        };
        const onElementInvalid = (el) => {
            invalidElementsRef.current.add(el);
            onUpdate();
        };
        const onUpdateStart = () => {
            updateStatus('UpdateStart');
        };
        const onUpdateBlocked = () => {
            updateStatus('UpdateBlocked');
        };
        const onUpdateSuccess = () => {
            updateStatus('UpdateSuccess');
        };
        const onUpdateError = (err) => {
            updateStatus('UpdateError', err);
        };
        const onRemoveStart = () => {
            updateStatus('DeleteStart');
        };
        const onRemoveSuccess = () => {
            updateStatus('DeleteSuccess');
        };
        const onRemoveError = (err) => {
            updateStatus('DeleteError', err);
        };
        doc.on(hadron_document_1.Element.Events.Added, onUpdate);
        doc.on(hadron_document_1.Element.Events.Edited, onUpdate);
        doc.on(hadron_document_1.Element.Events.Removed, onUpdate);
        doc.on(hadron_document_1.Element.Events.Reverted, onUpdate);
        doc.on(hadron_document_1.Element.Events.Invalid, onElementInvalid);
        doc.on(hadron_document_1.Element.Events.Valid, onElementValid);
        doc.on('update-start', onUpdateStart);
        doc.on('update-blocked', onUpdateBlocked);
        doc.on('update-success', onUpdateSuccess);
        doc.on('update-error', onUpdateError);
        doc.on('remove-start', onRemoveStart);
        doc.on('remove-success', onRemoveSuccess);
        doc.on('remove-error', onRemoveError);
        return () => {
            doc.on(hadron_document_1.Element.Events.Added, onUpdate);
            doc.off(hadron_document_1.Element.Events.Edited, onUpdate);
            doc.off(hadron_document_1.Element.Events.Removed, onUpdate);
            doc.off(hadron_document_1.Element.Events.Reverted, onUpdate);
            doc.off(hadron_document_1.Element.Events.Invalid, onElementInvalid);
            doc.off(hadron_document_1.Element.Events.Valid, onElementValid);
            doc.off('update-start', onUpdateStart);
            doc.off('update-blocked', onUpdateBlocked);
            doc.off('update-success', onUpdateSuccess);
            doc.off('update-error', onUpdateError);
            doc.off('remove-start', onRemoveStart);
            doc.off('remove-success', onRemoveSuccess);
            doc.off('remove-error', onRemoveError);
        };
    }, [doc, updateStatus]);
    (0, react_1.useEffect)(() => {
        if (isSuccess(status)) {
            const timeoutId = setTimeout(() => {
                updateStatus('Initial');
            }, 2000);
            return () => {
                clearTimeout(timeoutId);
            };
        }
    }, [status, updateStatus]);
    return { status, updateStatus, errorMessage };
}
const container = (0, emotion_1.css)({
    display: 'flex',
    paddingTop: tokens_1.spacing[2],
    paddingRight: tokens_1.spacing[2],
    paddingBottom: tokens_1.spacing[2],
    paddingLeft: tokens_1.spacing[3],
    alignItems: 'center',
    gap: tokens_1.spacing[2],
    borderBottomLeftRadius: 'inherit',
    borderBottomRightRadius: 'inherit',
});
const message = (0, emotion_1.css)({
    overflow: 'hidden',
    textOverflow: 'ellipsis',
});
const buttonGroup = (0, emotion_1.css)({
    display: 'flex',
    marginLeft: 'auto',
    gap: tokens_1.spacing[2],
});
const button = (0, emotion_1.css)({
    flex: 'none',
});
function getColorStyles(status, darkMode) {
    switch (status) {
        case 'Editing':
            return {
                backgroundColor: darkMode ? palette_1.palette.black : palette_1.palette.gray.light2,
            };
        case 'ContainsErrors':
        case 'UpdateError':
        case 'UpdateBlocked':
        case 'Deleting':
        case 'DeleteError':
        case 'DeleteStart':
            return {
                backgroundColor: darkMode ? palette_1.palette.red.dark3 : palette_1.palette.red.light2,
                color: darkMode ? palette_1.palette.red.light2 : palette_1.palette.red.dark3,
            };
        case 'UpdateStart':
            return {
                backgroundColor: palette_1.palette.blue.light2,
                color: palette_1.palette.blue.dark3,
            };
        case 'DeleteSuccess':
        case 'UpdateSuccess':
            return {
                backgroundColor: palette_1.palette.green.light2,
                color: palette_1.palette.green.dark3,
            };
        default:
            return {
                backgroundColor: palette_1.palette.yellow.light2,
                color: palette_1.palette.yellow.dark3,
            };
    }
}
const EditActionsFooter = ({ doc, editing, deleting, modified = false, containsErrors = false, alwaysForceUpdate = false, onUpdate, onDelete, onCancel, }) => {
    const { status: _status, updateStatus, errorMessage, } = useHadronDocumentStatus(doc, editing, deleting);
    const darkMode = (0, use_theme_1.useDarkMode)();
    const status = containsErrors
        ? 'ContainsErrors'
        : modified
            ? 'Modified'
            : _status;
    const statusMessage = StatusMessages[status];
    if (status === 'Initial') {
        return null;
    }
    return (react_1.default.createElement("div", { className: container, style: getColorStyles(status, darkMode), "data-testid": "document-footer", "data-status": status },
        react_1.default.createElement("div", { className: message, "data-testid": "document-footer-message" }, errorMessage ?? statusMessage),
        !isSuccess(status) && (react_1.default.createElement("div", { className: buttonGroup },
            react_1.default.createElement(leafygreen_1.Button, { type: "button", size: "xsmall", className: button, "data-testid": "cancel-button", onClick: () => {
                    doc.cancel();
                    onCancel?.();
                    updateStatus('Initial');
                }, disabled: isCancelDisabled(status) }, "Cancel"),
            react_1.default.createElement(leafygreen_1.Button, { type: "button", size: "xsmall", className: button, "data-testid": isDeleting(status) ? 'delete-button' : 'update-button', onClick: () => {
                    if (isDeleting(status)) {
                        onDelete();
                    }
                    else {
                        onUpdate(alwaysForceUpdate || status === 'UpdateBlocked');
                    }
                }, disabled: isPrimaryActionDisabled(status) }, isDeleting(status)
                ? 'Delete'
                : alwaysForceUpdate || status === 'UpdateBlocked'
                    ? 'Replace'
                    : 'Update')))));
};
exports.default = EditActionsFooter;
//# sourceMappingURL=document-edit-actions-footer.js.map